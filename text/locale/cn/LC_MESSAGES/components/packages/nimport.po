# 
msgid ""
msgstr ""
"Project-Id-Version: Modelica by Example 0.2.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-04-14 10:14-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dongping Xie <dongping.xie.tud@gmail.com>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/components/packages/nimport.rst:4
msgid "Importing Physical Types"
msgstr "导入物理类型"

#: ../../source/components/packages/nimport.rst:6
msgid ""
"In the previous section, we learned how to reference types defined in other "
"packages.  This spares the developer from having to constantly define things"
" in their local model.  Instead, they can place definitions in packages and "
"then reference those packages."
msgstr ""
"在前面的小节里，我们学会了如何引用其他包中定义的类型。"
"这令开发者不必不断地在自己的局部模型进行重复定义。"
"相反，他们可以将定义放在包内，然后去引用这些软件包。"

#: ../../source/components/packages/nimport.rst:11
msgid ""
"However, references with long fully qualified names can be tedious to type "
"over and over again.  For that reason, Modelica includes an ``import`` "
"statement that allows us to use a definition as if it were defined locally."
msgstr ""
"不过，一遍又一遍地键入冗长的全限定名进行引用不一定十分有趣。"
"因此，Modelica语言包括\ ``import``\ 语句，令我们可以方便地使用这些定义，仿佛这些定义是在本模型进行的一样。"

#: ../../source/components/packages/nimport.rst:16
msgid ""
"Recall again, this example from a previous discussion on :ref:`physical-"
"types`:"
msgstr ""
"再次回忆前面讨论\ :ref:`physical-types`\ 时的这个例子："

#: ../../source/components/packages/nimport.rst:22
msgid ""
"The previous section described how we could avoid defining these types "
"locally by using types from the :ref:`msl`.  But we can also use the "
"``import`` command to import those types from the Modelica Standard Library "
"once and then use them without having to specify their fully qualified "
"names.  The resulting code would look something like:"
msgstr ""
"前面已经介绍了，我们要如何通过使用\ :ref:`msl`\ 内的类型以避免进行本地定义。"
"但是，我们也可以使用\ ``import``\ 命令一次性地从Modelica语言标准库中导入这些类型，然后不需输入指定其全限定名而去使用它们。"
"这样代码变为如下："

#: ../../source/components/packages/nimport.rst:32
msgid ""
"Here we have replaced the type definitions with ``import`` statements. Note "
"how the highlighted lines are identical to the previous code. Let's look at "
"two of these import statements more closely to understand what effect they "
"have on the model.  Let's start with the following import statement:"
msgstr ""
"在这里，我们将类型定义换成\ ``import``\ 语句。"
"注意被高亮行如何等价于以前的代码。"
"让我们仔细观察其中的两个导入语句以了解其对模型的影响。"
"首先观察下面的导入语句："

#: ../../source/components/packages/nimport.rst:42
msgid ""
"This imports the type ``Modelica.SIunits.Temperature`` into the current "
"model.  By default, the name of this imported type will be the last name in "
"the fully qualified name, *i.e.,* ``Temperature``.  This means that with "
"this ``import`` statement present, we can simply use the type name "
"``Temperature`` and that will automatically refer back to "
"``Modelica.SIunits.Temperature``."
msgstr ""
"这将类型\ ``Modelica.SIunits.Temperature``\ 导入到当前的模型。"
"默认情况下，导入类型的名称会是全限定名最后一项的名称，即\ ``Temperature``\ 。"
"这意味着，只要有上述\ ``import``\ 语句，"
"我们可以简单地使用类型名\ ``Temperature``\ ，而引用将自动转到\ ``Modelica.SIunits.Temperature``\ 处。"

#: ../../source/components/packages/nimport.rst:49
msgid "Now let's look at another ``import`` statement:"
msgstr "现在，让我们来看看另一种\ ``import``\ 语句： "

#: ../../source/components/packages/nimport.rst:55
msgid ""
"The syntax here is a little bit different.  In this case, the type that we "
"are importing is ``Modelica.SIunits.CoefficientOfHeatTransfer``.  But "
"instead of creating a local type based on the last name in the fully "
"qualified name, *i.e.,* ``CoefficientOfHeatTransfer`` we are specifying that"
" the local type should be ``ConvectionCoefficient``.  In this case, this "
"allows us to use the name we originally used in our earliest examples. In "
"this way, we can avoid refactoring any code that used the previous name.  "
"Another reason for specifying an alternative name (other than the default "
"one that the Modelica compiler would normally assign) would be to avoid name"
" collision.  Imagine we wished to import two types from two different "
"packages, *e.g.,*"
msgstr ""
"这里的语法有点不同。"
"在这种情况下，我们正在导入的类型是\ ``Modelica.SIunits.CoefficientOfHeatTransfer``\ 。"
"但是，相对于直接用全限定名最后一项的名称，即\ ``CoefficientOfHeatTransfer``\ ，"
"我们将此类型的本地名称指定为\ ``ConvectionCoefficient``\ 。"
"在这里，改变名称允许我们使用在最初几个例子中定义的名称。"
"通过这种方式，我们能够避免重构任何使用了旧名称的代码。"
"另一个指定替代名称（而非Modelica编译器通常指派的默认名称）的原因是为了避免命名冲突。"
"试想，我们希望从两个不同的包导入两种类型，如："

#: ../../source/components/packages/nimport.rst:73
msgid ""
"This would leave us two types both named ``Temperature``.  By defining an "
"alternative name for the local alias, we could do something like this:"
msgstr ""
"这将使两种名为\ ``Temperature``\ 的类型。"
"通过为本地别名定义替代名称，我们进行以下行为："

#: ../../source/components/packages/nimport.rst:0
msgid "SI Units"
msgstr "国际单位"

#: ../../source/components/packages/nimport.rst:84
msgid ""
"Note that this example imports imperial units just to demonstrate how a "
"potential name clash might occur.  But it is very bad practice to do this in"
" practice.  When using Modelica you should always use SI units and never use"
" any other system of units.  If you want to enter data or display results in"
" other units, please use the ``displayUnit`` attribute discussed previously "
"in the section on :ref:`attributes`."
msgstr ""
"请注意，此示例导入英制单位只是为了演示潜在的命名冲突可能如何发生。"
"但这样做在实践中是非常不好的做法。"
"使用Modelica语言时，用户应该完全使用国际单位，切勿使用任何其他单位系统。"
"如果你想用其他单位来输入数据或显示效果，请使用在 \ :ref:`attributes`\ 小节里讨论的\ ``displayUnit``\ 属性。"

#: ../../source/components/packages/nimport.rst:92
msgid ""
"There is one last form of the ``import`` statement worth discussing which is"
" the wildcard import statement.  Importing units one unit at a time can be "
"tedious.  The wildcard import allows us to import **all** types from a given"
" package at once.  Recall the following earlier example:"
msgstr ""
"\ ``import``\ 语句最后一个值得讨论的形式是通配符导入语句。"
"一个一个地导入单位可能有些乏味。"
"通配符导入允许我们从给定的包里一次性导入\ **所有**\ 类型。"
"回想一下早前的如下例子："

#: ../../source/components/packages/nimport.rst:101
msgid ""
"We could replace these type definitions with import statements, *e.g.*,"
msgstr ""
"我们可以用导入语句替换这些类型定义，如："

#: ../../source/components/packages/nimport.rst:112
msgid ""
"However, the more types we bring in, the more import statements we need to "
"add.  Instead, we could write our model as follows:"
msgstr ""
"不过，导入的类型越多，我们需要添加的导入语句就越多。"
"相对地，我们可以将模型写成如下形式："

#: ../../source/components/packages/nimport.rst:119
msgid ""
"Note the highlighted ``import`` statement.  This single (wildcard) import "
"statement imports all definitions from ``Modelica.SIunits`` into the current"
" model.  With wildcard imports, there is no option to \"rename\" the types."
"  They will have exactly the name locally as they have in the named package."
msgstr ""
"注意高亮的\ ``import``\ 语句。"
"这条（通配符）导入语句从\ ``Modelica.SIunits``\ 导入其中的所有定义到当前的模型里。"
"通配符导入语句不能\ “重命名”类型。"
"导入类型的本地名称将和其在包内的名称一样。"

#: ../../source/components/packages/nimport.rst:125
msgid ""
"Before using wildcard imports, be sure to read :ref:`this caveat <wildcards-"
"harmful>`."
msgstr ""
"在使用通配符进口之前，请务必阅读\ :ref:`\ 这条警告\ <wildcards-harmful>`\ 。"

#: ../../source/components/packages/nimport.rst:128
msgid ""
"In this chapter, we've seen how ``import`` statements can be used to import "
"types from other packages.  As it turns out, ``import`` statements are not "
"always that useful.  When models are being developed within a graphical "
"modeling environment, tools generally use the least ambiguous and most "
"explicit method for reference types: using fully qualified names.  After "
"all, when using a graphical tool the length of the name is not an issue "
"because it doesn't need to be typed.  This also avoids issues with name "
"lookup, naming conflicts, etc."
msgstr ""
"在本章里，我们已经看到\ ``import``\ 语句如何用于从其他包内导入类型。"
"事实证明，\ ``import``\ 语句并非总是那么有用的。"
"当使用图形化建模环境开发模型时，工具一般采用歧义最少、最明确的方法去引用类型：使用全限定名。"
"毕竟，使用图形工具时，名称的长度不会是问题了，用户不再需要输入类型的名称。"
"这也避免了名称查找，命名冲突等问题。"
