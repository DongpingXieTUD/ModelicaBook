# 
msgid ""
msgstr ""
"Project-Id-Version: Modelica by Example 0.2.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-04-14 10:14-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/behavior/functions/func_annos.rst:4
msgid "Function Annotations"
msgstr ""
"函数标注"

#: ../../source/behavior/functions/func_annos.rst:6
msgid ""
"We've already discussed :ref:`annotations` in general.  Modelica includes a "
"number of standard annotations that are specifically used in conjunction "
"with functions.  These meaning of these annotations is formally defined in "
"the Modelica Specification.  In this section, we'll talk about the three "
"general categories of annotations for functions and provide some discussion "
"of why you need them and how to use them."
msgstr ""
"在 :ref:`annotations` 章节中，我们已经对标注进行了讨论。Modelica语言包括一些专门用于函数连接功能的标准标注。"
"这就意味着，这些标注是在Modelica规范中正式定义的。在本节中，我们将讨论与函数相关的三大类标注，并讨论这些标注的必要性以及"
"如何使用这些标注。"

#: ../../source/behavior/functions/func_annos.rst:15
msgid "Mathematical Annotations"
msgstr ""
"数学函数标注"

#: ../../source/behavior/functions/func_annos.rst:17
msgid ""
"The first class of annotations are ones that provide additional mathematical"
" information about the function.  Because functions are written using "
"``algorithm`` sections, it is not generally possible to derive equations for"
" the behavior of the function and many symbolic manipulations are therefore "
"not possible.  However, using the annotations in this section allows us to "
"augment the function definition with such information."
msgstr ""
"第一大类标注的主要功能是为数学函数提供一些额外的信息。因为这些数学函数的功能都是在 ``algorithm`` 部分实现的，因此"
"通常情况下，不能根据Modelica语言的符号操作得出上述函数方程的功能。但是，可以使用本节中的标注来增加函数定义的相关信息。"

#: ../../source/behavior/functions/func_annos.rst:26
msgid "``derivative``"
msgstr ""
"导数"

#: ../../source/behavior/functions/func_annos.rst:30
msgid ""
"As was saw in the ref:`polynomial-evaluation` example, there are "
"circumstances where we would like to inform the Modelica compiler how to "
"compute the derivative of a given function.  This is done by adding the "
"``derivative`` annotation in the function."
msgstr ""
"正如我们在 :ref:`polynomial-evaluation` 示例中讨论的那样，有些情况下，我们需告诉Modelica编译器如何计算给定函数的"
"导数。上述功能主要是通过在函数定义时添加 ``derivative`` 标注来实现的。"

#: ../../source/behavior/functions/func_annos.rst:36
msgid "Simple First Derivative"
msgstr ""
"简单的一阶导数"

#: ../../source/behavior/functions/func_annos.rst:38
msgid ""
"The basic use of the ``derivative`` annotation is to specify the name of "
"another Modelica function that computes the first derivative of the function"
" being annotated.  For example:"
msgstr ""
" ``derivative`` 标注的基本用途是为了指定另一个Modelica函数的名称，用来计算被标注函数的一阶导数。例如："

#: ../../source/behavior/functions/func_annos.rst:63
msgid ""
"Note that the first arguments to the derivative function, ``df``, in this "
"case, are the same as for the original function, ``f``.  Those arguments are"
" then followed by the differential versions of the input arguments to the "
"original function.  Finally, the output(s) of the derivative function are "
"the differential versions of the output(s) of the original function.  It "
"sounds complicated, but hopefully the same code conveys how simple the "
"construction really is."
msgstr ""
"通过上述例子可以看到，在这种情况下，导数函数的第一个参数 ``df`` 与原始函数的 ``f`` 具有相同的功能。"
"然后，紧随这些参数后面的是不同版本的输入变量。最后，导数函数的输出变量等同于不同版本下的原始函数的输出变量。"
"听上去上述过程非常复杂，实际上，通过相同功能的代码构建的上述结构是非常简单的。"

#: ../../source/behavior/functions/func_annos.rst:71
msgid ""
"Given such a Modelica function, the Modelica compiler can use such a "
"function to compute various derivatives, *e.g.*,"
msgstr ""
"给出如下的Modelica函数，Modelica编译器就可以使用下述函数来计算各种函数的导数， *即*, "

#: ../../source/behavior/functions/func_annos.rst:80
msgid "Insensitivity to Some Arguments"
msgstr ""
"不敏感参数"

#: ../../source/behavior/functions/func_annos.rst:82
msgid ""
"Now consider a case where :math:`\\frac{\\partial y}{\\partial v}` is zero."
"  The derivative function will be passed this zero value or an array of zero"
" values, if the argument was an array.  That zero value will then be used in"
" several calculations inside the derivative function. Most, if not all, of "
"these will be multiplications and the results of those calculations will "
"therefore be zeros.  Those zeros will then be added to the final result, but"
" will have no impact.  In other words, there are many calculations that "
"could be skipped because they won't have any impact on the result."
msgstr ""
"考虑这样一种情况，当表达式 :math:`\\frac{\\partial y}{\\partial v}` 等于0时，导数函数将会传递这个零值（或零值数组，当参数为数组时）。"
"上述零值会在导数函数内部被调用几次，其中大多数（如果不是全部）将调用零值做乘法，因此计算的结果也将为零。最终，这些计算结果将会"
"与其他结果相加，但是对函数的最终输出没有任何影响。换句话说，这种情况下，有很多计算可以跳过，因为它们对结果不会有任何影响。"

#: ../../source/behavior/functions/func_annos.rst:92
msgid ""
"In such cases, Modelica offers a way to avoid these calculations.  If the "
"Modelica compiler knows *a priori* that one of the differentials is zero, it"
" can check (among the set of ``derivative`` annotations) if there are any "
"functions that compute the derivative for that case. These cases are "
"specified using the ``zeroDerivative`` argument to the ``derivative`` "
"annotation.  So, in the case of our example function ``f``, we could add the"
" following annotation:"
msgstr ""
"在这种情况下，Modelica语言提供了一种避免上述冗余计算的方法。如果Modelica编译器能 *预先* 知道参数的微分为0，它就"
"可以检查（在 ``derivative`` 标注部分）是否有函数计算导数。这些情况是通过在 ``derivative`` 标注部分使用 ``zeroDerivative`` 参数"
"进行指定的。因此，对于上述示例中的函数 ``f`` ，我们增加了如下标注内容："

#: ../../source/behavior/functions/func_annos.rst:111
msgid "where ``df_onlyx`` would then be defined as:"
msgstr ""
"其中， ``df_onlyx`` 函数被定义为如下形式："
""
#: ../../source/behavior/functions/func_annos.rst:124
msgid ""
"Note that the ``dy`` term is not included here.  This function is "
"specifically for cases where ``dy`` is zero.  Because ``dy`` doesn't appear "
"in the arguments, this function includes only those calculations involving "
"``dx``."
msgstr ""
"通过比较可以看到，此函数不包括 ``dy`` 项，因此，只适用于 ``dy`` 为0的情况。因为，参数不包括 ``dy`` 项，该函数只包括"
"那些涉及参数 ``dx`` 的计算方程。"

#: ../../source/behavior/functions/func_annos.rst:130
msgid "Second Derivatives"
msgstr ""
"二阶导数"

#: ../../source/behavior/functions/func_annos.rst:132
msgid ""
"There are a few more variations worth covering here.  The first is how to "
"specify what the **second** derivative of a function is.  This is done by "
"adding an ``order`` argument.  Note that a function can have multiple "
"``derivative`` annotations, *e.g.,*"
msgstr ""
"对于二阶导数，这里有一些变化需要说明一下。首先，需要定义什么是函数的 **二阶** 导数。这主要是通过添加一个 ``order`` 变量"
"来实现的。需要注意的是，函数可以包括多个 ``derivative`` 标注， *即,* "
#: ../../source/behavior/functions/func_annos.rst:165
msgid ""
"Hopefully there are no real surprises here.  In order to compute the second "
"derivative, it is necessary to add an additional annotation ``derivative`` "
"annotation to the original function, *i.e.,*"
msgstr ""
"希望你对上述内容并不陌生。为了实现二阶导数的计算，需要在原函数内添加额外的 ``derivative`` 标注部分， *即,* "

#: ../../source/behavior/functions/func_annos.rst:173
msgid ""
"This additional annotation has an additional argument ``order`` which "
"indicates which derivative that function computes."
msgstr ""
"这些额外的标注增加了一个 ``order`` 变量用于表明函数求解的是哪阶导数。"

#: ../../source/behavior/functions/func_annos.rst:177
msgid "Non-Real Arguments"
msgstr ""
"非实数参数"

#: ../../source/behavior/functions/func_annos.rst:179
msgid ""
"There is one additional complication to discuss.  What if the function has "
"arguments that don't represent real numbers, *e.g.*,"
msgstr ""
"此外，对于其他一些复杂情况还需讨论，例如，函数内包含一些非实数的参数， *即*, "

#: ../../source/behavior/functions/func_annos.rst:192
msgid ""
"Here, it makes no sense to take the derivative of this function with respect"
" to the ``y`` argument, since it is an integer.  Any non-real argument can "
"be ignored when formulating the derivative.  So, if we wished to compute the"
" derivative of this function, we would do it as follows:"
msgstr ""
"对于上述函数，可以看到参数 ``y`` 的数据类型是整型，因此计算它的导数就没有什么意义了。对于任何非实数的参数，可以忽略其导数求解。"
"因此，如果我们希望计算上述函数的导数，可以采用下述方式："

#: ../../source/behavior/functions/func_annos.rst:218
msgid ""
"In other words, the differential arguments only apply to arguments that are "
"real."
msgstr ""
"换句话说，我们只对那些参数类型为实数的进行微分计算。"

#: ../../source/behavior/functions/func_annos.rst:223
msgid "``inverse``"
msgstr ""
"逆函数"

#: ../../source/behavior/functions/func_annos.rst:227
msgid ""
"During our discussion on :ref:`nonlinearities`, we showed how the "
"``inverse`` annotation can be used to tell the Modelica compiler how to "
"compute the inverse of a function.  The goal of an inverse function is to "
"solve explicitly for one of the current function's input arguments.  As "
"such, the ``inverse`` annotation contains an explicit equation involving the"
" input and output variables of the current function, but used in conjunction"
" with another function to explicitly compute one of the input arguments."
msgstr ""
"在 :ref:`nonlinearities` 章节中，我们讨论了使用 ``inverse`` 标注“告诉”Modelica编译器如何计算相应函数的逆函数。"
"逆函数的求解目标是得到输入参数关于输出变量之间确定的关系表达式。因此， ``inverse`` 标注包含一个涉及当前函数输入、输出"
"变量的显示方程，与另一个方程联合求解输入变量的表达式。"

#: ../../source/behavior/functions/func_annos.rst:236
msgid "For example, for a Modelica function defined as follows:"
msgstr ""
"例如，对于一个Modelica函数定义如下："

#: ../../source/behavior/functions/func_annos.rst:249
msgid ""
"we see that ``b`` can be computed by passing ``a`` and ``c`` as arguments to"
" the function ``h_inv_b`` which would be defined as follows:"
msgstr ""
"根据上述代码，我们可以看到，通过在函数 ``h_inv_b`` 中传递输入变量 ``a`` 和 ``c`` ，就可以计算得到参数 ``b`` 的表达式，"
"如下所示："
#: ../../source/behavior/functions/func_annos.rst:265
msgid "Code Generation"
msgstr ""
"代码生成"
#: ../../source/behavior/functions/func_annos.rst:267
msgid ""
"The next class of annotations are related to how function definitions are "
"translated into code for simulation.  These annotations allow the model "
"developer to provide hints to the Modelica compiler on how the code "
"generation process should be done."
msgstr ""
"另一大类标注是关于如何将定义的函数翻译成仿真用的代码。这些标注允许模型开发者在Modelica编译器生成代码的过程提供"
"相应的暗示。"

#: ../../source/behavior/functions/func_annos.rst:275
#: ../../source/behavior/functions/func_annos.rst:333
msgid "``Inline``"
msgstr ""
" ``Inline`` "
#: ../../source/behavior/functions/func_annos.rst:279
msgid ""
"The ``Inline`` annotation is a hint to the Modelica compiler that the "
"statements in the function should be \"inlined\".  The value of the "
"annotation is used to suggest whether inlining should be done.  The default "
"value (if no ``Inline`` annotation is present) is ``false``. The following "
"is a function that uses the ``Inline`` annotation:"
msgstr ""
" ``Inline`` 标注用于提示Modelica编译器函数中的声明语句应执行 \"内嵌\" 功能。此标注的值用于提示是否应执行内嵌功能，"
"其默认值为 ``false`` （如果函数定义中没有出现 ``Inline`` 标注）。下面是使用 ``Inline`` 标注定义的函数示例："

#: ../../source/behavior/functions/func_annos.rst:296
msgid ""
"Here we see that the ``Inline`` annotation suggests that the Modelica "
"compiler should inline the ``SimpleCalculation`` function.  The function is "
"inlined by replacing invocations of the function with the statements in the "
"function that compute the output result. This is useful for functions that "
"perform very simple calculations. In those cases, the \"cost\" (in CPU time)"
" of calling the function is on the same order of magnitude as the cost of "
"the work performed by the function.  By inlining the function, the cost of "
"the function call can be eliminated while still preserving the purpose of "
"the function."
msgstr ""
"在上述例子中，我们可以看到， ``Inline`` 标注表明Modelica编译器应内嵌上述定义的 ``SimpleCalculation`` 函数。"
"函数的内嵌是通过调用计算输出变量的函数进行替换的。这对于执行非常简单计算功能的函数是非常有用的。这些情况下，"
"调用该函数的 \"成本\" （计算机CPU的计算时间）与函数执行的成本基本是一个数量级的。通过内嵌函数，调用函数的成本"
"可以大大消除，同时依然能实现函数的功能。"

#: ../../source/behavior/functions/func_annos.rst:306
msgid ""
"The ``Inline`` function is merely a hint to the Modelica compiler. The "
"compiler is not obligated to inline the function.  Also, the compiler's "
"ability to inline the function will depend on the complexity of the "
"function.  It is not necessary possible (or even desirable) to inline a "
"function in general."
msgstr ""
" ``Inline`` 标注的功能只是用于提示Modelica编译器，编译器不会自动关联内嵌函数。此外，编译器内嵌函数的能力取决于"
"函数的复杂程度。通常情况下，编译器没有必要（或者期望）去内嵌函数。"

#: ../../source/behavior/functions/func_annos.rst:313
#: ../../source/behavior/functions/func_annos.rst:333
msgid "``LateInline``"
msgstr ""
" ``LateInline`` "
#: ../../source/behavior/functions/func_annos.rst:317
msgid ""
"Much like the :ref:`inline-anno` annotation, the ``LateInline`` function "
"tells the Modelica compiler that it would be more efficient to inline the "
"function.  The ``LateInline`` annotation is also assigned a ``Boolean`` "
"value to specify whether the function should be inlined or not.  The "
"difference between the ``Inline`` and ``LateInline`` annotations is that "
"``LateInline`` indicates that inlining should be performed after symbolic "
"manipulation has been performed.  A full discussion of the potential "
"interactions between inlining and other symbolic manipulations is beyond the"
" scope of this book."
msgstr ""
"与 :ref:`inline-anno` 标注一样， ``LateInline`` 标注的功能是告诉Modelica编译器采用内嵌函数的方式将更有效。"
" ``LateInline`` 标注也会分配一个 ``布尔`` 值用以指定是否应采用内嵌函数的方式。 ``Inline`` 和 ``LateInline`` 标注"
"的区别是， ``LateInline`` 标注表明应在符号运算完成后执行内嵌功能。关于函数内嵌以及符号运算之间的交互关系超出了"
"本书的讨论范围。"

#: ../../source/behavior/functions/func_annos.rst:328
msgid ""
"It should be noted that the ``LateInline`` annotation takes precedence over "
"the ``Inline`` annotation if they are both applied to a function, *i.e.,*"
msgstr ""
"还有一点需要注意，当一个函数内同时应用了 ``Inline`` 和 ``LateInline`` 标注时， ``LateInline`` 标注的优先级要高于 ``Inline`` 标注，"
" *即,* "

#: ../../source/behavior/functions/func_annos.rst:333
msgid "Interpretation"
msgstr ""
"说明"
#: ../../source/behavior/functions/func_annos.rst:335
#: ../../source/behavior/functions/func_annos.rst:335
#: ../../source/behavior/functions/func_annos.rst:336
#: ../../source/behavior/functions/func_annos.rst:337
msgid "``false``"
msgstr ""
" ``false`` "
#: ../../source/behavior/functions/func_annos.rst:335
msgid "``Inline=false``"
msgstr ""
" ``Inline=false`` "
#: ../../source/behavior/functions/func_annos.rst:336
#: ../../source/behavior/functions/func_annos.rst:337
#: ../../source/behavior/functions/func_annos.rst:338
#: ../../source/behavior/functions/func_annos.rst:338
msgid "``true``"
msgstr ""
" ``true`` "
#: ../../source/behavior/functions/func_annos.rst:336
msgid "``Inline=true``"
msgstr ""
" ``Inline=true`` "
#: ../../source/behavior/functions/func_annos.rst:337
#: ../../source/behavior/functions/func_annos.rst:338
msgid "``LateInline=true``"
msgstr ""
" ``LateInline=true`` "
#: ../../source/behavior/functions/func_annos.rst:344
msgid "External Functions"
msgstr ""
"外部函数"

#: ../../source/behavior/functions/func_annos.rst:346
msgid ""
"The final class of annotations are related to functions that are defined as "
"``external``.  Such functions often depend on external include files or "
"libraries.  These annotations inform the Modelica compiler of these "
"dependencies and where to locate them."
msgstr ""
"最后一大类标注是与定义的 ``external`` 函数相关的。这些外部函数的定义通常都依靠外部文件或库，"
"使用这类标注就是为了通知Modelica编译器这些依赖关系以及如何定位这些外部函数。"

#: ../../source/behavior/functions/func_annos.rst:354
msgid "``Include``"
msgstr ""
" ``Include`` 标注"
#: ../../source/behavior/functions/func_annos.rst:358
msgid ""
"The ``Include`` annotations is used whenever the code generated by a "
"Modelica compiler requires an include statement.  Typically this is required"
" when external libraries are being referenced.  The value of the ``Include``"
" annotation should be the string that should be inserted into the generated "
"code, *e.g.,*"
msgstr ""
"通常情况下，Modelica编译器生成代码过程中如果参考了相应的外部库，需添加相应的 ``Include`` 标注用于声明include需求。"
" ``Include`` 标注的值是一个字符串并且应嵌入到生成的代码文件中， *即,* "

#: ../../source/behavior/functions/func_annos.rst:370
msgid ""
"The value of the ``Include`` annotation is a string.  If it included "
"embedded strings, they need to be escaped."
msgstr ""
" ``Include`` 标注的值是一个字符串，如果它包含嵌入的字符串，需进行相应的转义。"

#: ../../source/behavior/functions/func_annos.rst:376
msgid "``IncludeDirectory``"
msgstr ""
" ``IncludeDirectory`` "

#: ../../source/behavior/functions/func_annos.rst:380
msgid ""
"As already discussed, the :ref:`include-anno` annotation allows include "
"directives to be inserted into generated code.  The ``IncludeDirectory`` "
"annotation specifies what directory should be searched to find the content "
"specified with the ``Include`` annotation."
msgstr ""
"在 :ref:`include-anno` 标注部分，我们已经讨论了该标注允许在生成的代码内插入路径。"
" ``IncludeDirectory`` 标注指定了 ``Include`` 标注声明的内容应在哪个目录下搜索。"

#: ../../source/behavior/functions/func_annos.rst:386
msgid ""
"The value of this annotation is a string.  The string can represent a "
"directory or it can be a URL.  For example, the default value for the "
"``IncludeDirectory`` annotation is:"
msgstr ""
"该标注的值是一个字符串，字符串可以是一个目录或者URL。例如， ``IncludeDirectory`` 标注的默认值如下所示："
""
#: ../../source/behavior/functions/func_annos.rst:394
msgid "We'll explain the meaning of these :ref:`modelica-urls` shortly."
msgstr ""
"稍后，我们将对 :ref:`modelica-urls` 的含义进行解释。"

#: ../../source/behavior/functions/func_annos.rst:397
msgid "``Library``"
msgstr ""
" ``Library`` "

#: ../../source/behavior/functions/func_annos.rst:401
msgid ""
"The ``Library`` annotation is used to specify any compiled libraries that a "
"function might depend on.  The value of library can be either a simple "
"string, representing the name of the library, or an array of such strings, "
"*i.e.,*"
msgstr ""
" ``Library`` 标注主要用于指定函数可能依赖的所有编译库，该标注的值可以是一个表示库名字的字符串，也可以是"
"上述字符串组成的数组， *即,* "
#: ../../source/behavior/functions/func_annos.rst:410
msgid "or"
msgstr ""
"或者"
#: ../../source/behavior/functions/func_annos.rst:416
msgid ""
"The Modelica compiler will then use this information during the \"linking\" "
"of the generated code."
msgstr ""
"Modelica编译器在生成代码 \"连接\" 时将使用这些信息。"

#: ../../source/behavior/functions/func_annos.rst:420
msgid "``LibraryDirectory``"
msgstr ""
" ``LibraryDirectory`` "

#: ../../source/behavior/functions/func_annos.rst:424
msgid ""
"We have the same issue with ``Library`` that we have with ``Include``. The "
"``Library`` annotation tells us what we need to add, but not where to find "
"it.  In this way, the ``LibraryDirectory`` annotation serves the same role "
"as the :ref:`include-directory-anno` annotation.  Like the "
"``IncludeDirectory`` annotation, it can also be a URL.  It's default value "
"is:"
msgstr ""
"对于 ``Library`` 和 ``Include`` 标注，我们有同样的问题。 ``Library`` 标注告诉我们需要添加那些库文件，但却没有告诉我们去"
"哪里查找。另外， ``LibraryDirectory`` 与 :ref:`include-directory-anno` 标注具有相同的作用，如同 ``IncludeDirectory`` 标注，"
" ``LibraryDirectory`` 标注的值也可以是一个URL，其默认值如下所示："

#: ../../source/behavior/functions/func_annos.rst:28
#: ../../source/behavior/functions/func_annos.rst:225
#: ../../source/behavior/functions/func_annos.rst:277
#: ../../source/behavior/functions/func_annos.rst:315
#: ../../source/behavior/functions/func_annos.rst:356
#: ../../source/behavior/functions/func_annos.rst:378
#: ../../source/behavior/functions/func_annos.rst:399
#: ../../source/behavior/functions/func_annos.rst:422
msgid "annotations"
msgstr ""

#: ../../source/behavior/functions/func_annos.rst:28
msgid "standard annotations; derivative"
msgstr ""

#: ../../source/behavior/functions/func_annos.rst:225
msgid "standard annotations; inverse"
msgstr ""

#: ../../source/behavior/functions/func_annos.rst:277
msgid "standard annotations; Inline"
msgstr ""

#: ../../source/behavior/functions/func_annos.rst:315
msgid "standard annotations; LateInline"
msgstr ""

#: ../../source/behavior/functions/func_annos.rst:356
msgid "standard annotations; Include"
msgstr ""

#: ../../source/behavior/functions/func_annos.rst:378
msgid "standard annotations; IncludeDirectory"
msgstr ""

#: ../../source/behavior/functions/func_annos.rst:399
msgid "standard annotations; Library"
msgstr ""

#: ../../source/behavior/functions/func_annos.rst:422
msgid "standard annotations; LibraryDirectory"
msgstr ""
