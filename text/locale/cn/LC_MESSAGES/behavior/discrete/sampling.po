# 
msgid ""
msgstr ""
"Project-Id-Version: Modelica by Example 0.2.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-04-14 10:14-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/behavior/discrete/sampling.rst:4
msgid "Synchronous Systems"
msgstr "同步系统"
#: ../../source/behavior/discrete/sampling.rst:6
msgid ""
"In Modelica version 3.3, new features were introduced to address concerns "
"about non-deterministic discrete behavior [Elmqvist]_.  In this section, "
"we'll present some examples of how these issues presented themselves before "
"version 3.3 and show how these new features help address them."
msgstr ""
"Modelica语言3.3版引入了一个新功能以解决有关非确定性离散行为的问题\ [Elmqvist]_ \ 。"
"本节将先介绍这些问题在3.3版本之前的表现。然后，我们将用例子展示新功能如何能帮助解决这类问题。"

#: ../../source/behavior/discrete/sampling.rst:12
msgid "To start, consider the following model:"
msgstr "先考虑下列模型："

#: ../../source/behavior/discrete/sampling.rst:18
msgid ""
"If you look carefully, you will see that ``x`` and ``y`` are both computed "
"at discrete times.  Furthermore, they are both sampled initially at the "
"start of the simulation and then again every 0.1 seconds.  But the question "
"is, are they really identical?  To help address this question, we include "
"the variable ``e`` which measures the difference between them."
msgstr ""
"倘若你仔细观察，你会发现\ ``x``\ 和\ ``y``\ 都在离散的时间点上被计算。"
"此外，两变量的采样时点都是在仿真开始时以及之后的每0.1秒。"
"但问题是，它们真的一样吗？"
"为了更容易解决这个问题，我们加入变量\ ``e``\ 以计算两者间的差。 "

#: ../../source/behavior/discrete/sampling.rst:28
msgid ""
"Simulating this model, we get the following trajectories for ``x`` and "
"``y``.  Of course, they look identical.  But in order to really determine if"
" there are any differences between them, let's plot the error value, ``e``:"
msgstr ""
"对模型进行仿真，我们会得到如下的\ ``x``\ 、\ ``y``\ 轨迹。"
"当然，两个轨迹看上去是一样的。 但要真正确定它们之间是否存在任何不同，我们绘制了误差值\ ``e``\ ："

#: ../../source/behavior/discrete/sampling.rst:36
msgid "Now, let's consider the following model:"
msgstr "现在，让我们考虑一下模型："

#: ../../source/behavior/discrete/sampling.rst:42
msgid ""
"Here, we set up a common signal that triggers the assignment to both "
"variables.  In this way, we can be sure that when the ``tick`` signal "
"becomes true, both ``x`` and ``y`` will be assigned a value.  Sure enough, "
"if we run this model, we see that the error is always zero:"
msgstr ""
"在这里，我们设置了一个共同的信号以触发两个变量的赋值操作。"
"通过这种方式，我们可以确定，当\ ``tick``\ 信号变为真时，"
"无论是\ ``x``\ 还是\ ``y``\ 都将被赋予一个值。"
"显然，运行这个模型后我们可以看到，误差永远为零："

#: ../../source/behavior/discrete/sampling.rst:50
msgid ""
"This kind of approach, where each signal is sampled based on a common "
"\"tick\" (or clock), is a good way to avoid determinism issues.  However, "
"what about cases where you have one signal that samples at a higher rate "
"than another, but you know that at certain times they should be sampled "
"together?  Consider the following example:"
msgstr ""
"在这样的做法里，每个信号都是基于一个共同的“节拍”（或时钟） 进行取样的。"
"这是一个很好的避免确定性问题的方式。"
"但是，如果你有两个不同频率的信号，且已知在特定的时点两者会被同时取样，那么情况又是如何呢？"
"请考虑如下例子："

#: ../../source/behavior/discrete/sampling.rst:60
msgid ""
"In this case, the variable ``tick`` is a counter.  Every time it changes, we"
" update the values of ``x`` and ``y``.  So this much is identical to the "
"previous models.  However, we added a third signal, ``z``, that is sampled "
"only when the value of ``tick`` is odd.  So ``x`` and ``y`` are sampled "
"twice as often.  But every time ``z`` is updated, we can be sure that ``x`` "
"and ``y`` are updated at exactly the same time.  Simulating this model gives"
" us:"
msgstr ""
"在这种情况下，变量\ ``tick``\ 是计数器。"
"每次此变量改变时，我们会更新\ ``x``\ 和\ ``y``\ 的值。"
"所以，直到这一点都是与先前的模型相同的。"
"然而，我们增加了第三个信号\ ``z``\ 。而该信号仅在当\ ``tick``\ 值是为奇时才会进行采样。"
"所以相比之下，\ ``x``\ 和\ ``y``\ 的采样次数为其的两倍。"
"但我们可以肯定的是，每次\ ``z``\ 更新时，\ ``x``\ 和\ ``y``\ 是在完全相同的时点进行更新。"
"对模型进行仿真我们会得到一下结果："

#: ../../source/behavior/discrete/sampling.rst:71
msgid ""
"This is the approach taken in Modelica prior to version 3.3.  But version "
"3.3 introduced some new features that allow us to more easily express these "
"situations."
msgstr ""
"这是Modelica语言在3.3版本之前所采用的方法。"
"但3.3版本引入了一些新的功能以帮助我们表述这些情况。"

#: ../../source/behavior/discrete/sampling.rst:75
msgid "Consider the following model:"
msgstr "请考虑以下模型："

#: ../../source/behavior/discrete/sampling.rst:81
msgid ""
"Now, instead of relying on a ``when`` statement, we use an enhanced version "
"of the ``sample`` function where the first argument is an expression to "
"evaluate to determine the sampled value and the second argument is used to "
"tell us when to evaluate it.  Let's work through these lines one by one and "
"discuss them.  First we have:"
msgstr ""
"Now, instead of relying on a ``when`` statement, we use an enhanced version of the ``sample`` function 
"现在，我们使用一个增强版的\ ``sample``\ （取样）函数，不再用\ ``when``\ 语句。"
"这个\ ``sample``\ 函数的首个参数是待取样的表达式，第二个参数则是取样的时间间隔。"
"让我们逐行阅读并讨论下面的代码。首先，我们有："

#: ../../source/behavior/discrete/sampling.rst:153
msgid ""
"\"Fundamentals of Synchronous Control in Modelica\", Hilding Elmqvist, "
"Martin Otter and Sven-Erik Mattsson "
"http://www.ep.liu.se/ecp/076/001/ecp12076001.pdf"
msgstr ""

#: ../../source/behavior/discrete/sampling.rst:91
msgid ""
"Note that we have done away with the ``0.1``.  We no longer see any mention "
"of the clock interval as a real number.  Instead, we use the ``Clock`` "
"operator to the define clock interval for ``x`` as a rational number.  This "
"is important because it allows us to do exact comparisons between clocks.  "
"This brings us to the next line:"
msgstr ""
"注意，我们已经不再使用\ ``0.1``\ ，而且不再能看到表示为实数值的时钟间隔。"
"相反，我们使用\ ``Clock``\ 表达式为\ ``x``\ 定义一个有理数值的时钟间隔。"
"这一点很重要，因为这种做法允许我们对不同时钟进行精确比较。"
"让我们看下一行："

#: ../../source/behavior/discrete/sampling.rst:101
msgid ""
"Again, we see the rational representation of the clock.  What this means, in"
" practice, is that the Modelica compiler can know for certain that these two"
" clocks, ``x`` and ``y``, are identical because they are defined in terms of"
" integer quantities which allow exact comparison. This means that when "
"executing a simulation, we can know for certain that these two clocks will "
"trigger simultaneously."
msgstr ""
"再一次，我们看到在时钟间隔的有理表示。"
"这意味着在实践中，Modelica语言编译器可以确信这两个时钟\ ``x``\ 与\ ``y``\ 是相同的。"
"因为两者均是用可确切比较的整数量进行定义的。"
"也就是说，在执行仿真时，我们可以确信这两个时钟会同时触发。"

#: ../../source/behavior/discrete/sampling.rst:108
msgid ""
"If we wanted to create a clock that was exactly two times slower than ``x``,"
" we can use the ``subSample`` operator to accomplish this.  We see this in "
"the definition of ``z``:"
msgstr ""
"如果我们想创建一个正好是\ ``x``\ 两倍慢的时钟，那么我们可以使用\ ``subSample``\ 运算符来完成。"
"在\ ``z``\ 的定义里我们可以看到这种情况："

#: ../../source/behavior/discrete/sampling.rst:116
msgid ""
"Behind the scenes, the Modelica compiler can reason about these clocks.  It "
"knows that the ``x`` clock triggers every :math:`\\frac{1}{10}` of a second."
"  Using the information provided by the ``subSample`` operator the Modelica "
"compiler can therefore deduce that ``z`` triggers every "
":math:`\\frac{2}{10}` of a second. Conceptually, this means that ``z`` could"
" also have been defined as:"
msgstr ""
"Modelica语言编译器可以在幕后对这些时钟间的关系进行推理。"
"编译器知道每隔\ :math:`\\frac{1}{10}`\ 秒时钟\ ``x``\ 就会触发。"
"因此Modelica语言编译器可以使用\ ``subSample``\ 运算符所提供的信息推论出，"
"每隔\ :math:`\\frac{2}{10}`\ 秒时钟\ ``z``\ 就会触发。"
"理论上，这意味着\ ``z``\ 也可以被定义为："

#: ../../source/behavior/discrete/sampling.rst:127
msgid ""
"But by defining ``z`` using the ``subSample`` operator and defining it with "
"respect to ``x`` we ensure that ``z`` is always triggering at half the "
"frequency of ``x`` regardless of how ``x`` is defined."
msgstr ""
"但通过使用\ ``subSample``\ 运算符相对\ ``x``\ 去进行对\ ``z``\ 的定义，"
"我们可以确保无论\ ``x``\ 是如何定义的，\ ``z``\ 的触发频率总是\ ``x``\ 的一半。"

#: ../../source/behavior/discrete/sampling.rst:131
msgid ""
"In a similar way, we can define another clock, ``w`` that triggers 3 times "
"more frequently than ``x`` by using the ``superSample`` operator:"
msgstr ""
"类似地，我们可以使用\ ``superSample``\ 运算符定义另一个触发频率为\ ``x``\ 3倍的时钟\ ``w``\ 。"

#: ../../source/behavior/discrete/sampling.rst:138
msgid "Again, we could have defined ``w`` directly using ``sample`` with:"
msgstr "同样，我们可以直接使用\ ``sample``\ 以对\ ``w``\ 进行如下定义："

#: ../../source/behavior/discrete/sampling.rst:144
msgid ""
"But by using ``superSample``, we can ensure that ``w`` is always sampling "
"three times faster than ``x`` and six times faster than ``z`` (since ``z`` "
"is also defined with respect to ``x``)."
msgstr ""
"但使用\ ``superSample``\ 我们可以确保\ ``w``\ 的采样速度总是\ ``x``\ 的三倍、"
"\ ``z``\ 的六倍（因为\ ``z``\ 也是基于\ ``x``\ 定义的）。"

#: ../../source/behavior/discrete/sampling.rst:148
msgid ""
"The synchronous clock features in Modelica are relatively new.  As such, "
"they are not yet supported by all Modelica compilers.  To learn more about "
"these synchronous features and their applications see [Elmqvist]_ and/or the"
" Modelica Specification, version 3.3 or later."
msgstr ""
"Modelica语言的同步时钟特性是相对较新。"
"因此，并非所有的Modelica语言编译器都支持这些特性。"
"要了解更多有关这些同步功能及其应用，可以参考\ [Elmqvist]_\ 以及／或者3.3版以后的Modelica规范。"
