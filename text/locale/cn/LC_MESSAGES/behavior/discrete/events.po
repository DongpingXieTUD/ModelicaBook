# 
msgid ""
msgstr ""
"Project-Id-Version: Modelica by Example 0.2.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-04-14 10:14-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dongping Xie <dongping.xie.tud@gmail.com>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/behavior/discrete/events.rst:4
msgid "Events"
msgstr "事件"

#: ../../source/behavior/discrete/events.rst:8
msgid ""
"In the first chapter on :ref:`basic-equations` we saw examples of how to "
"describe continuous behavior.  The equations introduced in that chapter "
"applied at all times and the solutions to those equations were always "
"continuous.  In this chapter, we discussed the various ways in Modelica to "
"describe discrete behavior.  Events are the root cause of all discrete "
"behavior in Modelica."
msgstr ""
"在关于\\ :ref:`basic-equations`\\ "
"的第一章里，我们看到了描述连续行为的例子。在该章中介绍的方程在任何时候都有效，而且这些方程的解总是连续的。在本章中，我们讨论了Modelica语言用以描述离散行为的种种方法。事件导致所有Modelica内离散行为的根本原因。"

#: ../../source/behavior/discrete/events.rst:16
msgid "Conditional Expressions"
msgstr "条件表达式"

#: ../../source/behavior/discrete/events.rst:22
msgid ""
"Events are generated in one of two ways.  First, they can be generated by "
"conditional expressions.  In the first few examples in this chapter, we saw "
"that conditional expressions can trigger events.  If these conditional "
"expressions only involve the variable ``time``, then we call them \"time "
"events\".  The ``time`` variable is a built-in, global variable that is "
"treated as an \"input\" to all models."
msgstr ""
"事件的产生有以下两种可能。首先，时间可以用条件语句产生。在本章的前面几例，我们看到了条件表达式可以触发事件。倘若这些条件表达式仅仅涉及变量\\ "
"``time``\\ ，我们就将其成为“时间事件”。变量\\ ``time``\\ 是一个内建的全局变量，而且是所有模型的“输入”。"

#: ../../source/behavior/discrete/events.rst:31
msgid ""
"If events are generated because of conditional expressions that involve "
"solution variables, then we call them \"state events\".  The important "
"distinctions between time events and state events were discussed in the "
":ref:`first <cooling-revisited>` and :ref:`second <bouncing-ball>` sections "
"of this chapter, respectively."
msgstr ""
"如果事件是由涉及解内变量的条件表达式产生的，我们就将其成为“状态事件”。时间事件和状态时间的重要区别在本章内的\\ :ref:`\\ 第一个例子\\ "
"<cooling-revisited>`\\ 以及\\ :ref:`\\ 第二个例子\\ <bouncing-ball>`\\ 中分别作了讨论。"

#: ../../source/behavior/discrete/events.rst:37
msgid ""
"Conditional expressions can be created using the relational operators "
"(``>``, ``>=``, ``<``, ``<=``, ``==``) and logical operators (``not``, "
"``and``, ``or``).  As we saw in our discussion of :ref:`no-event`, it is "
"possible to suppress the events generated by these conditional expressions "
"by surrounding them with the ``noEvent`` operator."
msgstr ""
"创建条件表达式可以使用关系运算符（\\ ``>``\\ 、\\ ``>=``\\ 、\\ ``<``\\ 、\\ ``<=``\\ 、\\ "
"``==``\\ ）以及逻辑运算符（\\ ``not``\\ 、\\ ``and``\\ 、\\ ``or``\\ ）。而正如我们在\\ :ref"
":`no-event`\\ 的讨论结果，我们可以在条件表达式外加上\\ ``noEvent``\\ 运算符以抑制其事件的生成。"

#: ../../source/behavior/discrete/events.rst:43
msgid ""
"Frequently, these event generating conditional expressions occur in the "
"context of an ``if`` statement or an ``if`` expression.  But it should also "
"be noted that even a simple variable assignment, *e.g.,*"
msgstr "通常情况下，产生事件的条件表达式出现在一个\\ ``if``\\ 语句或\\ ``if``\\ 表达式的里面。但也应注意的是，即使是简单的变量赋值，例如："

#: ../../source/behavior/discrete/events.rst:53
msgid "can trigger an event to be generated."
msgstr "也可以触发事件的产生。"

#: ../../source/behavior/discrete/events.rst:104
msgid "Events and Functions"
msgstr "事件与函数"

#: ../../source/behavior/discrete/events.rst:158
msgid "``sample(expr,clock)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:56
msgid "Piecewise Constructions"
msgstr "分段构造"

#: ../../source/behavior/discrete/events.rst:58
msgid ""
"There is an important special case when dealing with conditional "
"expressions.  In some cases, it is useful to create an expression that is "
"constructed piecewise.  For example,"
msgstr "处理条件表示式时有一种特殊情况。在某些情况下，条件表达式是一种有效的创建构造分段表达式的方法。例如："

#: ../../source/behavior/discrete/events.rst:106
msgid ""
"In addition to being generated by conditional expressions, events can also "
"be generated by certain functions in Modelica."
msgstr "除了由条件表达式生成，事件还可以通过Modelica内的某些函数产生。"

#: ../../source/behavior/discrete/events.rst:110
msgid "Event Generating Functions"
msgstr "事件生成的函数"

#: ../../source/behavior/discrete/events.rst:112
msgid ""
"The following is a list of functions that generate events wherever the "
"return value has a discontinuity."
msgstr "以下是当其返回值不连续是就会产生事件的函数的列表。"

#: ../../source/behavior/discrete/events.rst:116
#: ../../source/behavior/discrete/events.rst:137
#: ../../source/behavior/discrete/events.rst:153
#: ../../source/behavior/discrete/events.rst:170
msgid "Function"
msgstr "函数"

#: ../../source/behavior/discrete/events.rst:116
#: ../../source/behavior/discrete/events.rst:137
#: ../../source/behavior/discrete/events.rst:153
#: ../../source/behavior/discrete/events.rst:170
msgid "Description"
msgstr "描述"

#: ../../source/behavior/discrete/events.rst:118
msgid "``div(x,y)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:118
msgid "Algebraic quotient with fractional part discarded."
msgstr "省去小数部分的代数商。"

#: ../../source/behavior/discrete/events.rst:119
msgid "``mod(x,y)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:119
msgid "Modulus of ``x``/``y``"
msgstr "``x``/``y``\\ 的模数"

#: ../../source/behavior/discrete/events.rst:120
msgid "``rem(x,y)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:120
msgid "Remainder from the algebraic quotient"
msgstr "代数除法的余数"

#: ../../source/behavior/discrete/events.rst:121
msgid "``ceil(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:121
msgid "Smallest integer not less than ``x``"
msgstr "不小于\\ ``x``\\ 的最小整数"

#: ../../source/behavior/discrete/events.rst:122
msgid "``floor(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:122
msgid "Largest integer not greater than ``x`` (returns a ``Real``)"
msgstr "不大于\\ ``x``\\ 的最大整数（返回\\ ``Real``\\ ）"

#: ../../source/behavior/discrete/events.rst:123
msgid "``integer(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:123
msgid "Largest integer not greater than ``x`` (returns an ``Integer``)"
msgstr "不大于\\ ``x``\\ 的最大整数（返回\\ ``Integer``\\ ）"

#: ../../source/behavior/discrete/events.rst:124
msgid "``initial()``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:124
msgid "``true`` during initialization, otherwise ``false``"
msgstr "初始化时为\\ ``true``\\ ，否则为\\ ``false``"

#: ../../source/behavior/discrete/events.rst:125
msgid "``terminal()``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:125
msgid "``true`` at end of simulation, otherwise ``false``"
msgstr "仿真结束时为\\ ``true``\\ ，否则为\\ ``false``"

#: ../../source/behavior/discrete/events.rst:126
msgid "``sample(t0,dt)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:126
msgid "Generates an event at ``t0`` and every ``dt`` seconds later"
msgstr "在\\ ``t0``\\ 时刻以及以后的每\\ ``dt``\\ 秒生成一个事件"

#: ../../source/behavior/discrete/events.rst:127
msgid "``edge(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:127
msgid "``true`` only at the instant that ``x`` is ``true``"
msgstr "仅在\\ ``x``\\ 变为\\ ``true``\\ 的一瞬间为\\ ``true`` "

#: ../../source/behavior/discrete/events.rst:128
msgid "``change(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:128
msgid "``true`` whenever ``x`` changes value"
msgstr "每当\\ ``x``\\ 改变时为\\ ``true`` "

#: ../../source/behavior/discrete/events.rst:132
msgid "Non-Event Generating Functions"
msgstr "不会产生事件的函数"

#: ../../source/behavior/discrete/events.rst:134
msgid "The following is a table of functions that do **not** generate events:"
msgstr "以下是\\ **不会**\\ 产生事件的函数的列表。"

#: ../../source/behavior/discrete/events.rst:139
msgid "``abs(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:139
msgid "Absolute value of ``x``"
msgstr "\\ ``x``\\ 的绝对值"

#: ../../source/behavior/discrete/events.rst:140
msgid "``sign(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:140
msgid "Sign of ``x`` (-1, 0, or 1)"
msgstr "\\ ``x``\\ 的符号（返回-1、0或1 ）"

#: ../../source/behavior/discrete/events.rst:141
msgid "``sqrt(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:141
msgid "Square root of ``x``"
msgstr "\\ ``x``\\ 的平方根"

#: ../../source/behavior/discrete/events.rst:142
msgid "``min(x,y)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:142
msgid "Minimum value between ``x`` and ``y``"
msgstr "\\ ``x``\\ 和\\ ``y``\\ 中的最小值"

#: ../../source/behavior/discrete/events.rst:143
msgid "``max(x,y)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:143
msgid "Maximum value between ``x`` and ``y``"
msgstr "\\ ``x``\\ 和\\ ``y``\\ 中的最大值"

#: ../../source/behavior/discrete/events.rst:147
msgid "Event Related Operators"
msgstr "与时间有关的操作符"

#: ../../source/behavior/discrete/events.rst:149
msgid ""
"The following operators provide special information about event generating "
"signals:"
msgstr "下面的操作符提供了用于产生事件的信号的特殊信息："

#: ../../source/behavior/discrete/events.rst:155
msgid "``pre(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:155
msgid "During an event, holds the value of ``x`` before the event"
msgstr "在事件的发生时保存了\\ ``x``\\ 在事件前的取值"

#: ../../source/behavior/discrete/events.rst:156
msgid "``previous(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:156
msgid "During clock tick, value of ``x`` during previous clock tick"
msgstr "在一个时钟节拍内保存了\\ ``x``\\ 在上个时钟节拍的取值"

#: ../../source/behavior/discrete/events.rst:157
msgid "``hold(x)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:157
msgid "Anytime, value of ``x`` during previous clock tick"
msgstr "任何时间都保存了\\ ``x``\\ 在上个时钟节拍的取值"

#: ../../source/behavior/discrete/events.rst:158
msgid "During clock tick, value of ``expr``"
msgstr "在一个时钟节拍内\\ ``expr``\\ 的取值"

#: ../../source/behavior/discrete/events.rst:159
msgid "``noEvent(expr)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:159
msgid "Suppresses events generated by ``expr``"
msgstr "抑制\\ ``expr``\\ 内产生的事件"

#: ../../source/behavior/discrete/events.rst:160
msgid "``smooth(expr,p)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:160
msgid "Indicates ``expr`` can be safely differentiated ``p`` times."
msgstr "表示\\ ``expr``\\ 至少\\ ``p``\\ 次可导"

#: ../../source/behavior/discrete/events.rst:164
msgid "Clock Related Operators"
msgstr "有关时钟的运算符"

#: ../../source/behavior/discrete/events.rst:166
msgid ""
"The following operators are used to create a manipulate clocks (event "
"generators that trigger at regular intervals):"
msgstr "下面的运算符用于创建取样时钟（在固定间隔内触发的事件产生器）："

#: ../../source/behavior/discrete/events.rst:172
msgid "``Clock(i,r)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:173
msgid "``Clock(dt)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:173
msgid "A clock that fires every :math:`dt` seconds where ``dt`` is a ``Real``"
msgstr "每隔\\ :math:`dt`\\ 秒触发的时钟。其中\\ ``dt``\\ 是\\ ``Real``\\ 。"

#: ../../source/behavior/discrete/events.rst:174
msgid "``subSample(u,s)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:174
msgid ""
"A clock that samples ``s`` times slower than the clock used to sample ``u`` "
"where ``s`` is an ``Integer``"
msgstr "采样速度为\\ ``u``\\ 采样速度\\ :math:`\\frac{1}{s}`\\ 倍的时钟，其中\\ ``s``\\ 为\\ ``Integer``\\ 。"

#: ../../source/behavior/discrete/events.rst:175
msgid "``superSample(u,s)``"
msgstr ""

#: ../../source/behavior/discrete/events.rst:178
msgid ""
"Note that the ``Clock`` constructor function is overloaded (*i.e.,* can take"
" different arguments).  It is worth reiterating that the synchronous clock "
"features in Modelica are relatively new.  As such, they are not yet "
"supported by all Modelica compilers.  To learn more about these synchronous "
"features and their applications see [Elmqvist]_ and/or the Modelica "
"Specification, version 3.3 or later."
msgstr ""
"注意\\ ``Clock``\\ "
"的构造函数被重载了（也就是说可以采用不同类型的参数）。值得重申的是，Modelica语言的同步时钟特性是相对较新。因此，并非所有的Modelica语言编译器都支持这些特性。要了解更多有关这些同步功能及其应用，可以参考\\"
" [Elmqvist]_\\ 以及／或者3.3版以后的Modelica规范。"

#: ../../source/behavior/discrete/events.rst:185
msgid ""
"\"Fundamentals of Synchronous Control in Modelica\", Hilding Elmqvist, "
"Martin Otter and Sven-Erik Mattsson "
"http://www.ep.liu.se/ecp/076/001/ecp12076001.pdf"
msgstr ""

#: ../../source/behavior/discrete/events.rst:172
msgid ""
"A clock that fires every :math:`\\frac{i}{r}` seconds where ``i`` and ``r`` "
"are both of type ``Integer``"
msgstr "每隔\\ :math:`\\frac{i}{r}`\\ 秒触发的时钟。其中\\ ``i``\\ 与\\ ``r``\\ 都是\\ ``Integer``\\ 类型的。"

#: ../../source/behavior/discrete/events.rst:175
msgid ""
"A clock that samples ``s`` times as fast as the clock used to sample ``u`` "
"where ``s`` is an ``Integer``"
msgstr "采样速度为\\ ``u``\\ 采样速度\\ ``s``\\ 倍的时钟，其中\\ ``s``\\ 为\\ ``Integer``\\ 。"

#: ../../source/behavior/discrete/events.rst:66
msgid ""
"It is hard for a Modelica compiler to reliably determine that such a "
"function is continuous and has continuous derivatives.  For this reason, "
"Modelica includes the ``smooth`` operator to explicitly express such "
"conditions.  For example, using the ``smooth`` operator as follows:"
msgstr ""
"Modelica编译器很难可靠地确定函数是否连续，"
"或者函数是否有连续导数。"
"出于这个原因，Modelica自带了\\ ``smooth``\\ 操作符用以明示这种情况。"
"例如，用以下形式使用\\ ``smooth``\\ 运算符："

#: ../../source/behavior/discrete/events.rst:76
msgid ""
"indicates that the expression is continuous as is and will remain continuous"
" if differentiated up to 2 times because"
msgstr ""
"表示该表达式是连续的，而且在两次微分后仍将保持连续。"

#: ../../source/behavior/discrete/events.rst:97
msgid ""
"Hence, the function, its first and second derivatives are continuous at "
":math:`x=0`, but the third derivative is discontinuous."
msgstr "因此，函数的第一及第二阶导数在\ :math:`x=0`\ 处连续，但第三阶导数则不连续。"

#: ../../source/behavior/discrete/events.rst:100
msgid ""
"Note that the ``smooth`` operator requires an upper bound to be specified."
msgstr ""
"注意\\ ``smooth``\\ 操作符需要指定一个可导次数的上界。"
