# 
msgid ""
msgstr ""
"Project-Id-Version: Modelica by Example 0.2.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-04-14 10:14-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/behavior/discrete/when.rst:4
msgid "When"
msgstr ""

#: ../../source/behavior/discrete/when.rst:8
msgid ""
"By using ``when``, we can express conditions we are interested in reacting "
"to and what we wish to do in response to them.  In this section, we'll "
"review the key ideas behind ``when`` statements.  A ``when`` statement has "
"the following general form:"
msgstr ""
"ÈÄöËøá‰ΩøÁî®\ ``when``\ ÔºåÊàë‰ª¨ÂèØ‰ª•Ë°®ËææÊàë‰ª¨ÊÑüÂÖ¥Ë∂£ÁöÑÊù°‰ª∂Âà§Êñ≠‰ª•ÂèäÂØπËøô‰∫õÊù°‰ª∂Âà§Êñ≠ÁöÑÂõûÂ∫î„ÄÇ"
"Âú®Êú¨ËäÇ‰∏≠ÔºåÊàë‰ª¨Â∞ÜÂõûÈ°æ\ ``when``\ ËØ≠Âè•ËÉåÂêéÁöÑ‰∏ªË¶ÅÊÄùÊÉ≥„ÄÇ"
"\ `` when``\ ËØ≠Âè•ÁöÑ‰∏ÄËà¨ÂΩ¢ÂºèÂ¶Ç‰∏ãÔºö"

#: ../../source/behavior/discrete/when.rst:22
msgid "``if`` vs. ``when``"
msgstr "ÂØπÊØî\ ``if``\ Âíå\ ``when``"

#: ../../source/behavior/discrete/when.rst:24
msgid ""
"In our discussion on :ref:`hysteresis`, we briefly discussed the difference "
"between an ``if`` statement and a ``when`` statement.  The statements in a "
"``when`` statement become active only for an instant when the triggering "
"conditional expression becomes true.  At all other times, the ``when`` "
"statement has no effect.  An ``if`` statement or ``if`` expression remains "
"active as long as the conditional expression is true.  If the ``if`` "
"statement or ``if`` expression includes an ``else`` clause then some branch "
"will always be active."
msgstr ""
"Âú®ÂâçÈù¢ÂØπ\ :ref:`hysteresis`\ ÁöÑËÆ®ËÆ∫ÈáåÔºåÊàë‰ª¨ÁÆÄË¶ÅÂú∞ËÆ®ËÆ∫‰∫Ü\ ``if``\ ËØ≠Âè•Âíå\ ``when``\ ËØ≠Âè•‰πãÈó¥ÁöÑÂå∫Âà´„ÄÇ"
"Âú®\ ``when``\ ËØ≠Âè•ÂÜÖÁöÑ‰ª£Á†Å‰ªÖ‰ºöÂú®Ëß¶ÂèëÊù°‰ª∂Ë°®ËææÂºè‰∏∫ÁúüÁöÑ‰∏ÄÁû¨Èó¥Ë¢´ÊøÄÊ¥ª„ÄÇ"
"Âú®ÊâÄÊúâÂÖ∂ÂÆÉÁöÑÊó∂ÂÄôÔºå\ ``when``\ ËØ≠Âè•‰∏ç‰ºöÊúâ‰ªª‰ΩïÂΩ±Âìç„ÄÇ"
"ËÄå\ ``if`` ÈôàËø∞Êàñ\ ``if``\ Ë°®ËææÂºèÂè™Ë¶ÅÂú®Êù°‰ª∂Ë°®ËææÂºè‰∏∫ÁúüÊó∂ÔºåÂÆÉ‰ª¨Â∞±ÊúâÊïà„ÄÇ"
"ÂÄòËã•\ ``if`` ÈôàËø∞Êàñ\ ``if``\ Ë°®ËææÂºèÂåÖÂê´‰∫Ü\ ``else``\ Â≠êÂè•ÔºåÈÇ£‰πàÊÄª‰ºöÊúâ‰∏Ä‰∏™ÂàÜÊîØÊúâÊïà„ÄÇ"

#: ../../source/behavior/discrete/when.rst:34
msgid "Expressions"
msgstr "Ë°®ËææÂºè"

#: ../../source/behavior/discrete/when.rst:36
msgid ""
"Most of the time, the expression ``expr`` is going to be a conditional "
"expression and usually it will involve relational operators.  Typical "
"examples of expressions frequently used with a ``when`` statement would be "
"``time>=2.0``, ``x>=y+2``, ``phi<=prev_phi`` and so on. Recall from our "
"discussion of the :ref:`interval-measurement` speed estimation algorithm "
"that you should **almost always** put the ``pre`` operator around any "
"variables in ``expr`` that also appear inside the ``when`` statement."
msgstr ""
"Â§ßÂ§öÊï∞Êó∂ÂÄôÔºå\ ``expr``\ Ë°®ËææÂºè‰ºöÊòØ‰∏™Êù°‰ª∂Ë°®ËææÂºèÔºåËÄå‰∏îÈÄöÂ∏∏‰ºöÊ∂âÂèäÂÖ≥Á≥ªËøêÁÆóÁ¨¶„ÄÇ"
"\ ``when``\ ËØ≠Âè•Â∏∏Áî®ÁöÑÊù°‰ª∂Ë°®ËææÂºèÊúâ‰æãÂ¶Ç\ ``time>=2.0``\ „ÄÅ\ ``x>=y+2``\ „ÄÅ\ ``phi<=prev_phi``\ Á≠â„ÄÇ"
"ÂõûÂøÜÂâçÈù¢Âú®ËÆ®ËÆ∫\ :ref:`interval-measurement`\ ÊµãÁÆóÁÆóÊ≥ïÊó∂ÔºåÂØπ‰∫éÂêåÊó∂Âá∫Áé∞Âú®\ ``expr``\ ‰ª•Âèä\ ``when``\ "
"Ë°®ËææÂºèÈáåÁöÑÂèòÈáèÔºå‰Ω†\ **Âá†‰πéÊÄªË¶Å**\ Âú®ÁªôËøô‰∫õÂèòÈáèÂä†‰∏ä\ ``pre``\ Êìç‰ΩúÁ¨¶„ÄÇ"

#: ../../source/behavior/discrete/when.rst:45
msgid ""
"In the :ref:`bouncing-ball` example, we saw a case where ``expr`` was not a "
"(scalar) conditional expression, but rather a vector of conditional "
"expressions.  Recall from that discussion that the ``when`` statement "
"becomes active if **any** of the conditions in the vector of expressions "
"becomes true."
msgstr ""
"Âú®\ :ref:`bouncing-ball`\ ÁöÑ‰æãÂ≠êÈáåÔºåÊàë‰ª¨ÈÅáÂà∞Ëøá\ ``expre``\ Âπ∂ÈùûÊúâ‰∏Ä‰∏™ÔºàÊ†áÈáèÔºâÊù°‰ª∂Ë°®ËææÂºèÔºåËÄåÊòØ"
"Áî±Êù°‰ª∂Ë°®ËææÂºèÂêëÈáèÁªÑÊàêÁöÑÊÉÖÂÜµ„ÄÇ"
"ËØ∑ÂõûÂøÜÂâçÈù¢ÂÖ≥‰∫éÊúâÂêëÈáèÂΩ¢ÂºèÊù°‰ª∂ËØ≠Âè•ÁöÑ\ ``when``\ ËØ≠Âè•ÁöÑËÆ®ËÆ∫ÔºöÂΩìÂêëÈáè‰∏≠ÁöÑ\ **‰ªª‰Ωï‰∏Ä‰∏™**\ Êù°‰ª∂Âèò‰∏∫ÁúüÊó∂Ôºå"
"\ ``when``\ ËØ≠Âè•Â∞±‰ºöË¢´ÊøÄÊ¥ª„ÄÇ"


#: ../../source/behavior/discrete/when.rst:52
msgid "Statements"
msgstr "ËØ≠Âè•"

#: ../../source/behavior/discrete/when.rst:54
msgid ""
"A ``when`` statement is used to define new values for some variables. These "
"new values can be assigned in one of two ways.  The first is by introducing "
"an equation of the form:"
msgstr ""
"\ `` when``ËØ≠Âè•ÁöÑ‰ΩúÁî®ÊòØ‰∏∫ÂèòÈáèÂÆö‰πâÊñ∞ÁöÑÂèñÂÄº„ÄÇ"
"Êàë‰ª¨ÂèØ‰ª•Áî®‰∏§ÁßçÊñπÊ≥ïÂÆö‰πâÊñ∞ÁöÑÂèñÂÄº„ÄÇ"
"Á¨¨‰∏ÄÁßçÊñπÊ≥ïÊòØÈÄöËøáÂ∞ÜÂÖ∑Êúâ‰ª•‰∏ãÂΩ¢ÂºèÁöÑÂÖ¨ÂºèÔºö"

#: ../../source/behavior/discrete/when.rst:62
msgid ""
"In this case, the variable ``var`` will be given the value of ``expr``.  "
"Within ``expr``, the ``pre`` operator should be used when referring to the "
"pre-event value for a variable.  Any variable assigned in this way is a "
"discrete variable.  This means that its value only changes during events.  "
"In other words, it will be a piecewise constant function.  Note, a variable "
"assigned in this way cannot be continuous over any interval in the "
"simulation."
msgstr ""
"Âú®ËøôÁßçÊÉÖÂÜµ‰∏ãÔºå\ ``var``\ Â∞Ü‰ºöÁ≠â‰∫é\ ``expr``\ ÁöÑÂèñÂÄº„ÄÇ"
"ËÄå ``expr``\ ÈáåÁöÑ\ ``pre``\ Êìç‰ΩúÁ¨¶Áî®‰∫éÊåá‰ª£ÂèòÈáèÂú®‰∫ã‰ª∂ÂâçÁöÑÂèñÂÄº„ÄÇ"
"‰ªª‰Ωï‰ª•ËøôÁßçÊñπÂºèËµãÂÄºÁöÑÂèòÈáèÂùá‰∏∫Á¶ªÊï£ÂèòÈáè„ÄÇ"
"ËøôÊÑèÂë≥ÁùÄÔºåËøô‰∫õÂèòÈáèÁöÑÂÄº‰ªÖÂú®‰∫ã‰ª∂ËøõË°åÊó∂ÂèëÁîüÂèòÂåñ„ÄÇ"
"Êç¢Âè•ËØùËØ¥ÔºåÂèòÈáèÂ∞ÜÊòØÂàÜÊÆµÂ∏∏Êï∞ÂáΩÊï∞„ÄÇ"
"ËØ∑Ê≥®ÊÑèÔºå‰ª•ËøôÁßçÊñπÂºèËµãÂÄºÁöÑÂèòÈáè‰∏çÂèØËÉΩÂú®‰ªøÁúüÁöÑ‰ªª‰ΩïÊó∂Èó¥Èó¥ÈöîÂÜÖÈÉΩ‰øùÊåÅËøûÁª≠„ÄÇ"

#: ../../source/behavior/discrete/when.rst:70
msgid ""
"If you want to explicitly mark a variable as discrete, you can prefix it "
"with the ``discrete`` qualifier (as we saw in the :ref:`sample-and-hold` "
"example earlier in this chapter) although this is not strictly necessary.  "
"By adding the ``discrete`` qualifier you ensure that the variable's value "
"must be determined within a ``when`` statement."
msgstr ""
"ËôΩÁÑ∂‰∏•Ê†ºËÄåË®ÄÂπ∂ÈùûÂøÖÈ°ªÔºå‰ΩÜÂ¶ÇÊûú‰Ω†ÊÉ≥ÊòéÁ°ÆÂú∞Â∞ÜÂèòÈáèÊ†áËÆ∞‰∏∫Á¶ªÊï£Ôºå‰Ω†ÂèØ‰ª•Áî®\ ``discrete``\ ÈôêÂÆöËØç‰Ωú‰∏∫ÂÖ∂ÂâçÁºÄ"
"Ôºà Ê≠£Â¶ÇÊàë‰ª¨Âú®Êú¨Á´†ÂâçÈù¢ÁöÑ\ :ref:`sample-and-hold`\ ÊâÄÁúãÂà∞ÁöÑ‰æãÂ≠ê‰∏ÄÊ†∑Ôºâ„ÄÇ"
"Ê∑ªÂä†\ ``discrete``\ ÈôêÂÆöËØçÂèØ‰ª•Á°Æ‰øùËØ•ÂèòÈáèÁöÑÂÄºÂøÖÈ°ªÁî±\ ``when``\ ËØ≠Âè•Êù•Á°ÆÂÆö„ÄÇ"

#: ../../source/behavior/discrete/when.rst:79
msgid ""
"The other way a variable can be given a value within a ``when`` statement, "
"as demonstrated in the :ref:`bouncing-ball` example, is by using the "
"``reinit`` operator.  In that case, the statement within the ``when`` "
"statement will take the form:"
msgstr ""
"Âè¶‰∏ÄÁßçÂú®\ ``when``\ ÂèòÈáèÈáå‰∏∫ÂèòÈáèËµãÂÄºÁöÑÊñπÊ≥ïÔºåÊ≠£Â¶ÇÂú®\ :ref:`bouncing-ball`\ ÁöÑ‰æãÂ≠êÈáå‰∏ÄÊ†∑ÔºåÊòØÈÄöËøá‰ΩøÁî®"
"\ ``reinit``\ Êìç‰ΩúÁ¨¶„ÄÇ"
"Âú®ËøôÁßçÊÉÖÂÜµ‰∏ãÔºå\ ``when``\ ËØ≠Âè•ÂÜÖÈÉ®ÁöÑ‰ª£Á†ÅÂ∞Ü‰ºöÊúâÂ¶Ç‰∏ãÂΩ¢ÂºèÔºö"

#: ../../source/behavior/discrete/when.rst:88
msgid ""
"When using the ``reinit`` operator, the variable, ``var``, **must be a "
"state**.  In other words, its solution must arise from solving a "
"differential equation.  The use of ``reinit`` on such a variable has the "
"effect of stopping the integration process, changing the value of the state "
"(and any other states that have the ``reinit`` operator applied to them "
"within the same ``when`` statement) and then resuming integration using what"
" are effectively a new set of initial conditions.  The values of all other "
"states not re-initialized with the ``reinit`` operator remain unchanged."
msgstr ""
"Âú®‰ΩøÁî®\ ``reinit``\ Êìç‰ΩúÁ¨¶Êó∂ÔºåÂèòÈáè\ ``var``\ **ÂøÖÈ°ªÊòØ‰∏Ä‰∏™Áä∂ÊÄÅ**\ „ÄÇ"
"Êç¢Âè•ËØùËØ¥ÔºåÊ≠§ÂèòÈáèÂøÖÈ°ªÊòØÂæÆÂàÜÊñπÁ®ãÊ±ÇËß£ÁöÑÁªìÊûú„ÄÇ"
"Âú®ËøôÊ†∑ÁöÑÂèòÈáèÈáå‰ΩøÁî®\ ``reinit``\ ‰ºöÂÅúÊ≠¢ÁßØÂàÜËøáÁ®ãÂπ∂ÊîπÂèòËØ•Áä∂ÊÄÅ"
" Ôºà‰ª•ÂèäÂÖ∂ÂÆÉÂú®Âêå‰∏Ä‰∏™\ ``when``\ ËØ≠Âè•ÈáåÊ∑ªÂä†‰∫Ü\ ``reinit``\ ÁöÑÔºâÁöÑÂÄº„ÄÇ"
"Á¥ßÊé•ÁùÄÔºåÁßØÂàÜÂÆûÈôÖ‰∏ä‰ΩøÁî®‰∫Ü‰∏ÄÂ•óÊñ∞ÁöÑÂàùÂßãÊù°‰ª∂ÈáçÊñ∞ÂºÄÂßã„ÄÇ"
"ËÄåÊ≤°Êúâ‰ΩøÁî®\ ``reinit``\ Êìç‰ΩúÁ¨¶ËøõË°åÈáçÊñ∞ÂàùÂßãÂåñÁöÑÂÖ∂‰ªñÁä∂ÊÄÅ‰ºö‰øùÊåÅ‰∏çÂèò„ÄÇ"

#: ../../source/behavior/discrete/when.rst:101
msgid "``algorithm`` Sections"
msgstr "``algorithm``\ ÊÆµËêΩ"

#: ../../source/behavior/discrete/when.rst:103
msgid ""
"One final note about ``when`` statements is how they interact with the "
"\"single assignment\" rule in Modelica.  This rule, from the specification, "
"states that there must be exactly one equation used to determine the value "
"of each variable.  As we saw in the sections on :ref:`speed-measurement` and"
" :ref:`hysteresis`, it is sometimes necessary (or least clearer) to express "
"behavior in terms of multiple assignments.  In those cases, if all the "
"assignments are included within a single ``algorithm`` section, they are "
"effectively combined into a single equation.  However, doing so will limit "
"the compiler's ability to perform symbolic manipulation and, therefore, may "
"impact simulation performance and/or reusability of the models."
msgstr ""
"One final note about ``when`` statements is how they interact with the \"single assignment\" rule in Modelica.  
"ÂÖ≥‰∫é\ ``when``\ Â£∞ÊòéÊúÄÂêéË¶ÅÊ≥®ÊÑèÁöÑÊòØÔºå‰ªñ‰ª¨‰∏é\Â¶Ç‰ΩïÁõ∏‰∫í‰ΩúÁî®‚ÄùÁöÑModelicaËØ≠Ë®ÄÂàÜÈÖç‰∏ÄÊ¨°\ ‚ÄúÁöÑËßÑÂàô„ÄÇ[21m
This rule, from the specification, states that there must be exactly one equation used to determine the value "
"of each variable.  
As we saw in the sections on :ref:`speed-measurement` and :ref:`hysteresis`, it is sometimes necessary (or least clearer) to express behavior in terms of multiple assignments.  
In those cases, if all the assignments are included within a single ``algorithm`` section, they are effectively combined into a single equation.  
However, doing so will limit the compiler's ability to perform symbolic manipulation and, therefore, may impact simulation performance and/or reusability of the models."

#: ../../source/behavior/discrete/when.rst:6
msgid "when"
msgstr ""

#: ../../source/behavior/discrete/when.rst:77
msgid "reinit"
msgstr ""

#: ../../source/behavior/discrete/when.rst:115
msgid ""
"It is also worth noting that if the semantics of an ``algorithm`` section "
"are needed during initialization, Modelica includes an ``initial algorithm``"
" section that is analogous to the ``initial equation`` section discussed in "
"the previous discussion on :ref:`initialization`.  The ``initial algorithm``"
" section will be applied only during the initialization phase to determine "
"initial conditions, just like an ``initial equation`` section, but the "
"``initial algorithm`` section will allow multiple assignments to the same "
"variable.  The same caveats apply with respect to symbolic manipulation."
msgstr ""
